package plugin

import (
	"fmt"
	"github.com/golang/glog"
	"google.golang.org/protobuf/compiler/protogen"
	"strings"
)

func GenerateEnt(gen *protogen.Plugin) error {
	glog.Infof("------------------------------------------------------ generating ent stuff ------------------------------------------------------------")
	writeGenerate(gen)
	writeEntc(gen)
	writeGqlGen(gen)
	writeResolver(gen)
	writeResolvers(gen)
	writeServer(gen)
	writeGoMod(gen)
	return nil
}

func writeGenerate(gen *protogen.Plugin) {
	g := gen.NewGeneratedFile("example/ent/generate.go", "")
	g.P("package ent")
	g.P()
	g.P(`//go:generate go run -mod=mod ./ent/entc.go`)
	g.P(`//go:generate go run -mod=mod github.com/99designs/gqlgen`)
}

func writeEntc(gen *protogen.Plugin) {
	g := gen.NewGeneratedFile("example/ent/ent/entc.go", "")
	g.P(entcContent)
}

func writeGqlGen(gen *protogen.Plugin) {
	g := gen.NewGeneratedFile("example/ent/gqlgen.yml", "")
	g.P(gqlgenContent)
	g.P("autobind:")
	g.P("  - entgen/ent")
	for _, f := range gen.Files {
		if !f.Generate {
			continue
		}
		for _, m := range f.Messages {
			if getMessageOptions(m).Gen {
				messageProtoName := getMessageProtoName(m)
				thing := fmt.Sprintf("  - entgen/ent/%s", strings.ToLower(messageProtoName))
				glog.Infof(thing)
				g.P(thing)
			} else {
			}
		}
	}
}

func writeResolver(gen *protogen.Plugin) {
	g := gen.NewGeneratedFile("example/ent/resolver.go", "")
	g.P(resolverContent)
}

func writeResolvers(gen *protogen.Plugin) {
	g := gen.NewGeneratedFile("example/ent/ent.resolvers.go", "")
	g.P(resolversContent)
	for _, f := range gen.Files {
		if !f.Generate {
			glog.Infof("writeResolvers skipping file: %s", f.Desc.FullName())
			continue
		}
		glog.Infof("writeResolvers handling file: %s", f.Desc.FullName())
		for _, m := range f.Messages {
			glog.Infof("writeResolvers handling message %s", getMessageProtoName(m))
			if getMessageOptions(m).Gen {
				messageProtoName := getMessageProtoName(m)
				definition := fmt.Sprintf("func (r *queryResolver) %s(ctx context.Context) ([]*ent.%s, error) {return r.client.%s.Query().All(ctx)}", messageProtoName+"s", messageProtoName, messageProtoName)
				glog.Infof(definition)
				g.P(definition)
			} else {
			}
		}
	}
}

func writeServer(gen *protogen.Plugin) {
	g := gen.NewGeneratedFile("example/ent/cmd/graphql/main.go", "")
	g.P(serverContent)
}

func writeGoMod(gen *protogen.Plugin) {
	g := gen.NewGeneratedFile("example/ent/go.mod", "")
	g.P(goModContent)
}

var resolversContent = `
package ent

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"context"
	"entgen/ent"
	"fmt"
)

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id int) (ent.Noder, error) {
	return r.client.Noder(ctx, id)
}

// Nodes is the resolver for the nodes field.
func (r *queryResolver) Nodes(ctx context.Context, ids []int) ([]ent.Noder, error) {
	return r.client.Noders(ctx, ids)
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
`
var goModContent = `
module entgen

go 1.21

require (
	entgo.io/contrib v0.4.5
	entgo.io/ent v0.13.1
	github.com/99designs/gqlgen v0.17.44
	github.com/mattn/go-sqlite3 v1.14.16
)

require (
	ariga.io/atlas v0.19.1-0.20240203083654-5948b60a8e43 // indirect
	github.com/agext/levenshtein v1.2.1 // indirect
	github.com/agnivade/levenshtein v1.1.1 // indirect
	github.com/apparentlymart/go-textseg/v13 v13.0.0 // indirect
	github.com/go-openapi/inflect v0.19.0 // indirect
	github.com/google/go-cmp v0.6.0 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/gorilla/websocket v1.5.0 // indirect
	github.com/hashicorp/golang-lru/v2 v2.0.7 // indirect
	github.com/hashicorp/hcl/v2 v2.13.0 // indirect
	github.com/mitchellh/go-wordwrap v0.0.0-20150314170334-ad45545899c7 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/sosodev/duration v1.2.0 // indirect
	github.com/vektah/gqlparser/v2 v2.5.11 // indirect
	github.com/vmihailenco/msgpack/v5 v5.0.0-beta.9 // indirect
	github.com/vmihailenco/tagparser v0.1.2 // indirect
	github.com/zclconf/go-cty v1.8.0 // indirect
	golang.org/x/exp v0.0.0-20221230185412-738e83a70c30 // indirect
	golang.org/x/mod v0.15.0 // indirect
	golang.org/x/text v0.14.0 // indirect
	golang.org/x/tools v0.18.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
`

var serverContent = `
package main

import (
	"context"
	entgen "entgen"
	"entgen/ent"
	"entgen/ent/migrate"
	"log"
	"net/http"

	"entgo.io/ent/dialect"
	"github.com/99designs/gqlgen/graphql/handler"
	"github.com/99designs/gqlgen/graphql/playground"

	_ "github.com/mattn/go-sqlite3"
)

func main() {
	// Create ent.Client and run the schema migration.
	client, err := ent.Open(dialect.SQLite, "file:ent?mode=memory&cache=shared&_fk=1")
	if err != nil {
		log.Fatal("opening ent client", err)
	}
	if err := client.Schema.Create(
		context.Background(),
		migrate.WithGlobalUniqueID(true),
	); err != nil {
		log.Fatal("opening ent client", err)
	}

	// Configure the server and start listening on :8081.
	srv := handler.NewDefaultServer(entgen.NewSchema(client))
	http.Handle("/",
		playground.Handler("Todo", "/query"),
	)
	http.Handle("/query", srv)
	log.Println("listening on :8081")
	if err := http.ListenAndServe(":8081", nil); err != nil {
		log.Fatal("http server terminated", err)
	}
}
`

var resolverContent = `
package ent

import (
    "entgen/ent"
    
    "github.com/99designs/gqlgen/graphql"
)

// Resolver is the resolver root.
type Resolver struct{ client *ent.Client }

// NewSchema creates a graphql executable schema.
func NewSchema(client *ent.Client) graphql.ExecutableSchema {
    return NewExecutableSchema(Config{
        Resolvers: &Resolver{client},
    })
}
`

var gqlgenContent = `
# schema tells gqlgen where the GraphQL schema is located.
schema:
  - ent.graphql

# resolver reports where the resolver implementations go.
resolver:
  layout: follow-schema
  dir: .

# gqlgen will search for any type names in the schema in these go packages
# if they match it will use them, otherwise it will generate them.
# This section declares type mapping between the GraphQL and Go type systems.
models:
  # Defines the ID field as Go 'int'.
  ID:
    model:
      - github.com/99designs/gqlgen/graphql.IntID
  Node:
    model:
      - entgen/ent.Noder
`

var entcContent = `
//go:build ignore

package main

import (
    "log"

    "entgo.io/ent/entc"
    "entgo.io/ent/entc/gen"
    "entgo.io/contrib/entgql"
)

func main() {
    ex, err := entgql.NewExtension(
        // Tell Ent to generate a GraphQL schema for
        // the Ent schema in a file named ent.graphql.
        entgql.WithSchemaGenerator(),
        entgql.WithSchemaPath("ent.graphql"),
		entgql.WithConfigPath("gqlgen.yml"),
    )
    if err != nil {
        log.Fatalf("creating entgql extension: %v", err)
    }
    opts := []entc.Option{
        entc.Extensions(ex),
    }
    if err := entc.Generate("./ent/schema", &gen.Config{}, opts...); err != nil {
        log.Fatalf("running ent codegen: %v", err)
    }
}
`
