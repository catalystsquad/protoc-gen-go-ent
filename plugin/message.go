package plugin

import (
	"fmt"
	"github.com/catalystsquad/protoc-gen-go-ent/config"
	ent "github.com/catalystsquad/protoc-gen-go-ent/options"
	"github.com/iancoleman/strcase"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"strings"
)

func HandleProtoMessage(gen *protogen.Plugin, file *protogen.File, message *protogen.Message) error {
	if shouldHandleMessage(message) {
		err := writeSchemaFile(gen, file, message)
		if err != nil {
			return err
		}
		if *config.GenerateApp {
			writeGraphqlFile(gen, file, message)
			writeResolvers(gen, file, message)
		}
		err = generateQueriesAndMutations(gen, message)
		if err != nil {
			return err
		}
		err = generateTests(gen, message)
		if err != nil {
			return err
		}
	}

	return nil
}

func writeSchemaFile(gen *protogen.Plugin, file *protogen.File, message *protogen.Message) error {
	g := createSchemaFile(gen, file, message)
	writeSchemaFileHeader(g, file, message)
	writeSchemaFileImports(g, message)
	writeSchemaFileStruct(g, message)
	err := WriteSchemaFileFields(g, message)
	if err != nil {
		return err
	}
	WriteSchemaFileAnnotations(g, message)
	err = WriteSchemaFileEdges(g, message)
	return err
}

func writeGraphqlFile(gen *protogen.Plugin, file *protogen.File, message *protogen.Message) {
	g := createGraphqlFile(gen, file, message)
	g.P("# file generated by protoc-gen-go-ent, do not modify")
	g.P("# extend may show errors in IDEs because type Mutation is undefined. This error can be ignored, gqlgen will glue these together into a cohesive mutation schema")
	writeMutationExtensions(g, message)
	writeQueryExtensions(g, message)
	messageFields := getMessageFields(message)
	inputName := getCreateInputName(message)
	if len(messageFields) > 0 {
		g.P("extend input ", inputName, " {")
		for _, field := range messageFields {
			fieldName := strcase.ToCamel(getFieldName(field))
			fieldInputName := getCreateInputName(getFieldMessage(field))
			g.P(indent, "create", fieldName, ": [", fieldInputName, "!]")
		}
		g.P("}")
	}
}

func writeMutationExtensions(g *protogen.GeneratedFile, message *protogen.Message) {
	name := getMessageProtoName(message)
	g.P("extend type Mutation {")
	g.P("  create", name, "(input: Create", name, "Input!): ", name, "!")
	g.P("  update", name, "(id: ID!, input: Update", name, "Input!): ", name, "!")
	g.P("  delete", name, "(id: ID!): Boolean!")
	g.P("}")
}

func writeQueryExtensions(g *protogen.GeneratedFile, message *protogen.Message) {
	name := getMessageProtoName(message)
	g.P("extend type Query {")
	g.P(indent, strcase.ToLowerCamel(name), "(id: ID!): ", name)
	g.P("}")
}

func getCreateInputName(message *protogen.Message) string {
	return fmt.Sprintf("Create%sInput", getMessageProtoName(message))
}

func writeResolvers(gen *protogen.Plugin, file *protogen.File, message *protogen.Message) {
	g := createResolversFile(gen, file, message)
	g.P(getResolversContent(message))
}

func getResolversContent(message *protogen.Message) string {
	return strings.Replace(resolversTemplate, "Blarf", getMessageProtoName(message), -1)
}

var resolversTemplate = `

package app

// CreateBlarf is the resolver for the createBlarf field.
func (r *mutationResolver) CreateBlarf(ctx context.Context, input ent.CreateBlarfInput) (*ent.Blarf, error) {
	return ent.FromContext(ctx).Blarf.Create().SetInput(input).Save(ctx)
}

// UpdateBlarf is the resolver for the updateBlarf field.
func (r *mutationResolver) UpdateBlarf(ctx context.Context, input ent.UpdateBlarfInput) (*ent.Blarf, error) {
	return ent.FromContext(ctx).Blarf.UpdateOneID(id).SetInput(input).Save(ctx)
}

// DeleteBlarf is the resolver for the deleteBlarf field.
func (r *mutationResolver) DeleteBlarf(ctx context.Context, id int) (*bool, error) {
	err := ent.FromContext(ctx).Blarf.DeleteOneID(id).Exec(ctx)
    // returns true if there are no errors
	return err == nil, err
}

// Blarf is the resolver for the Blarf field.
func (r *queryResolver) Blarf(ctx context.Context, id uuid.UUID) (*ent.Blarf, error) {
	Blarf, err := r.client.Blarf.Get(ctx, id)
	return Blarf, err
}`

func shouldHandleMessage(message *protogen.Message) bool {
	messageOptions := getMessageOptions(message)
	return messageOptions.Gen
}

func createSchemaFile(gen *protogen.Plugin, file *protogen.File, message *protogen.Message) *protogen.GeneratedFile {
	fileName := getSchemaFileName(file, message)
	g := gen.NewGeneratedFile(fileName, ".")
	return g
}

func createGraphqlFile(gen *protogen.Plugin, file *protogen.File, message *protogen.Message) *protogen.GeneratedFile {
	fileName := getAppFileName(fmt.Sprintf("%s.graphql", strings.ToLower(getMessageProtoName(message))))
	g := gen.NewGeneratedFile(fileName, ".")
	return g
}

func createResolversFile(gen *protogen.Plugin, file *protogen.File, message *protogen.Message) *protogen.GeneratedFile {
	fileName := getAppFileName(fmt.Sprintf("%s.resolvers.go", strings.ToLower(getMessageProtoName(message))))
	g := gen.NewGeneratedFile(fileName, ".")
	return g
}

func getSchemaFileName(file *protogen.File, message *protogen.Message) string {
	suffix := fmt.Sprintf("%s.pb.ent.go", strings.ToLower(strcase.ToSnake(getMessageProtoName(message))))
	if *config.GenerateApp {
		return getAppFileName(getEntDirectory(), "schema", suffix)

	}
	return fmt.Sprintf("schema/%s", suffix)
}

func getGraphqlFileName() {

}

func getMessageGoName(message *protogen.Message) string {
	return message.GoIdent.GoName
}

func getMessageProtoName(message *protogen.Message) string {
	return string(message.Desc.Name())
}

func getPluralMessageProtoName(message *protogen.Message) string {
	return plural(getMessageProtoName(message))
}

func writeSchemaFileHeader(g *protogen.GeneratedFile, file *protogen.File, message *protogen.Message) {
	packageName := getMessageFilePackageName(file)
	g.P("// Code generated by protoc-gen-go-ent. DO NOT EDIT.")
	g.P()
	g.P("package ", packageName)
	g.P()
}

func getMessageFilePackageName(file *protogen.File) string {
	return "schema"
}

func writeSchemaFileImports(g *protogen.GeneratedFile, message *protogen.Message) {
	g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "entgo.io/ent"})
	g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "entgo.io/contrib/entgql"})
	g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "entgo.io/ent/schema"})
	messageOptions := getMessageOptions(message)
	for _, additonalImport := range messageOptions.AdditionalImports {
		g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: protogen.GoImportPath(additonalImport)})
	}
}

func writeSchemaFileStruct(g *protogen.GeneratedFile, message *protogen.Message) {
	structName := getMessageStructName(message)
	g.P(fmt.Sprintf("type %s struct {", structName))
	g.P("  ent.Schema")
	g.P("}")
}

func getMessageStructName(message *protogen.Message) string {
	return getMessageGoName(message)
}

func getMessageOptions(message *protogen.Message) ent.EntMessageOptions {
	options := message.Desc.Options()
	if options == nil {
		return ent.EntMessageOptions{}
	}
	v := proto.GetExtension(options, ent.E_Opts)
	if v == nil {
		return ent.EntMessageOptions{}
	}

	opts, ok := v.(*ent.EntMessageOptions)
	if !ok || opts == nil {
		return ent.EntMessageOptions{}
	}
	return *opts
}

func getNonIgnoredFields(message *protogen.Message) []*protogen.Field {
	fields := []*protogen.Field{}
	for _, field := range message.Fields {
		if !fieldIsIgnored(field) {
			fields = append(fields, field)
		}
	}

	return fields
}

func getNonMessageFields(message *protogen.Message) []*protogen.Field {
	fields := []*protogen.Field{}
	for _, field := range getNonIgnoredFields(message) {
		if !fieldTypeIsMessage(field) {
			fields = append(fields, field)
		}
	}

	return fields
}

func getMessageFields(message *protogen.Message) []*protogen.Field {
	fields := []*protogen.Field{}
	for _, field := range getNonIgnoredFields(message) {
		if fieldTypeIsMessage(field) {
			fields = append(fields, field)
		}
	}

	return fields
}

func getMessageField(name string, message *protogen.Message) *protogen.Field {
	for _, field := range message.Fields {
		if getFieldProtoName(field) == name {
			return field
		}
	}

	return nil
}
