package plugin

import (
	"fmt"
	"github.com/catalystsquad/protoc-gen-go-ent/config"
	ent "github.com/catalystsquad/protoc-gen-go-ent/options"
	"github.com/golang/glog"
	"github.com/iancoleman/strcase"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"strings"
)

func HandleProtoMessage(gen *protogen.Plugin, file *protogen.File, message *protogen.Message) error {
	if shouldHandleMessage(message) {
		err := writeSchemaFile(gen, file, message)
		if err != nil {
			return err
		}
		if *config.GenerateApp {
			writeGraphqlFile(gen, file, message)
			writeResolvers(gen, file, message)
		}

	}

	return nil
}

func writeSchemaFile(gen *protogen.Plugin, file *protogen.File, message *protogen.Message) error {
	g := createSchemaFile(gen, file, message)
	writeSchemaFileHeader(g, file, message)
	writeSchemaFileImports(g, message)
	writeSchemaFileStruct(g, message)
	WriteSchemaFileFields(g, message)
	WriteSchemaFileAnnotations(g, message)
	err := WriteSchemaFileEdges(g, message)
	return err
}

func writeGraphqlFile(gen *protogen.Plugin, file *protogen.File, message *protogen.Message) {
	g := createGraphqlFile(gen, file, message)
	name := getMessageProtoName(message)
	g.P("type Mutation {")
	g.P("  create", name, "(input: Create", name, "Input!): ", name, "!")
	g.P("  update", name, "(id: ID!, input: Update", name, "Input!): ", name, "!")
	g.P("  delete", name, "(id: ID!): Boolean!")
	g.P("}")
}

func writeResolvers(gen *protogen.Plugin, file *protogen.File, message *protogen.Message) {
	g := createResolversFile(gen, file, message)
	g.P(getResolversContent(message))
}

func getResolversContent(message *protogen.Message) string {
	return strings.Replace(resolversTemplate, "Blarf", getMessageProtoName(message), -1)
}

var resolversTemplate = `

package app

// CreateBlarf is the resolver for the createBlarf field.
func (r *mutationResolver) CreateBlarf(ctx context.Context, input ent.CreateBlarfInput) (*ent.Blarf, error) {
	return r.client.Blarf.Create().SetInput(input).Save(ctx)
}

// UpdateBlarf is the resolver for the updateBlarf field.
func (r *mutationResolver) UpdateBlarf(ctx context.Context, input ent.UpdateBlarfInput) (*ent.Blarf, error) {
	return r.client.Blarf.UpdateOneID(id).SetInput(input).Save(ctx)
}

// DeleteBlarf is the resolver for the deleteBlarf field.
func (r *mutationResolver) DeleteBlarf(ctx context.Context, id int) (*bool, error) {
	err := r.client.Blarf.DeleteOneID(id).Exec(ctx)
    // returns true if there are no errors
	return err == nil, err
}`

func shouldHandleMessage(message *protogen.Message) bool {
	messageOptions := getMessageOptions(message)
	return messageOptions.Gen
}

func createSchemaFile(gen *protogen.Plugin, file *protogen.File, message *protogen.Message) *protogen.GeneratedFile {
	fileName := getSchemaFileName(file, message)
	glog.Infof("writing schema file: %s", fileName)
	g := gen.NewGeneratedFile(fileName, ".")
	return g
}

func createGraphqlFile(gen *protogen.Plugin, file *protogen.File, message *protogen.Message) *protogen.GeneratedFile {
	fileName := getAppFileName(fmt.Sprintf("%s.graphql", strings.ToLower(getMessageProtoName(message))))
	g := gen.NewGeneratedFile(fileName, ".")
	return g
}

func createResolversFile(gen *protogen.Plugin, file *protogen.File, message *protogen.Message) *protogen.GeneratedFile {
	fileName := getAppFileName(fmt.Sprintf("%s.resolvers.go", strings.ToLower(getMessageProtoName(message))))
	g := gen.NewGeneratedFile(fileName, ".")
	return g
}

func getSchemaFileName(file *protogen.File, message *protogen.Message) string {
	suffix := fmt.Sprintf("%s.pb.ent.go", strings.ToLower(strcase.ToSnake(getMessageProtoName(message))))
	if *config.GenerateApp {
		return getAppFileName(getEntDirectory(), "schema", suffix)

	}
	return fmt.Sprintf("schema/%s", suffix)
}

func getGraphqlFileName() {

}

func getMessageGoName(message *protogen.Message) string {
	return message.GoIdent.GoName
}

func getMessageProtoName(message *protogen.Message) string {
	return string(message.Desc.Name())
}

func writeSchemaFileHeader(g *protogen.GeneratedFile, file *protogen.File, message *protogen.Message) {
	packageName := getMessageFilePackageName(file)
	g.P("// Code generated by protoc-gen-go-ent. DO NOT EDIT.")
	g.P()
	g.P("package ", packageName)
	g.P()
}

func getMessageFilePackageName(file *protogen.File) string {
	return "schema"
}

func writeSchemaFileImports(g *protogen.GeneratedFile, message *protogen.Message) {
	g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "entgo.io/ent"})
	g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "entgo.io/contrib/entgql"})
	g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "entgo.io/ent/schema"})
	messageOptions := getMessageOptions(message)
	for _, additonalImport := range messageOptions.AdditionalImports {
		g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: protogen.GoImportPath(additonalImport)})
	}
}

func writeSchemaFileStruct(g *protogen.GeneratedFile, message *protogen.Message) {
	structName := getMessageStructName(message)
	g.P(fmt.Sprintf("type %s struct {", structName))
	g.P("  ent.Schema")
	g.P("}")
}

func getMessageStructName(message *protogen.Message) string {
	return getMessageGoName(message)
}

func getMessageOptions(message *protogen.Message) ent.EntMessageOptions {
	options := message.Desc.Options()
	if options == nil {
		return ent.EntMessageOptions{}
	}
	v := proto.GetExtension(options, ent.E_Opts)
	if v == nil {
		return ent.EntMessageOptions{}
	}

	opts, ok := v.(*ent.EntMessageOptions)
	if !ok || opts == nil {
		return ent.EntMessageOptions{}
	}
	return *opts
}

func getMessageField(name string, message *protogen.Message) *protogen.Field {
	for _, field := range message.Fields {
		if getFieldProtoName(field) == name {
			return field
		}
	}

	return nil
}
